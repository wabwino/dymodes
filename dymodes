#!/usr/bin/env python3
# - dynamic [usb] mode switch
"""
when invoked with '--edit-rules', it
edits the mode-switch rules instead
of printing out the command
"""

__app__ = "dymodes"
__version__ = "01-aug-2021"

import glob
import subprocess
import os
import re
import time
import sys
import shutil


RULES_FILE = "/lib/udev/rules.d/40-usb_modeswitch.rules"
RULE       = """# Produced by dymodes ({product})
ATTR{{idVendor}}=="{vid}", ATTR{{idProduct}}=="{pid}", \
RUN+="{usb_modeswitch} -v 0x{vid} -p 0x{pid} {cmd}"\n"""

should_edit_rules = False


def _error_exit(msg):
    print(msg, file=sys.stderr)
    exit(1)


def _check_tool(tool):
    """Check if a given tool is available on the system."""
    return bool(shutil.which(tool))


def _set_edit_rules():
    global should_edit_rules
    should_edit_rules = True


def print_help():
    print(__app__, "(" + __version__ + " release)")
    print(__doc__, end="")


def _process_args(options, args):
    """Does a kinda tightly-coupled argument processing."""
    if len(args) == 0:
        return
    if len(args) > 1:
        _error_exit("only one argument is expected")
    arg = args[0]
    if arg not in options:
        _error_exit("an unknown argument '{}'".format(arg))
    options[arg]['action']()
    if options[arg]['exit']:
        exit()


def is_detected():
    """Check if a modem is detected.  Returns a boolean."""
    def _check_ports(surfix):
        return glob.glob("/dev/tty{}*".format(surfix))
    return bool(_check_ports("USB") or _check_ports("ACM"))


def choose_device():
    """Present a menu to user for picking a device we should work on.

    Returns the chosen device.
    """
    def _get_input(devices):
        print("please select device")
        for i in range(len(devices)):
            print(" - ", i+1, ": ", devices[i]['name'].lower(), sep="")
            
        while True:
            val = input(": ")
            try:
                val = int(val)
                if val < 1 or val > len(devices):
                    raise ValueError
            except ValueError:
                print("(invalid input. please try again)")
            else:
                return devices[val-1]

    # - Get list of plugged-in USB devices from `lsusb`.
    output = subprocess.check_output('lsusb').decode('utf-8')
    regexp = r'^(?:[^\s]+\s){5}([0-9a-f]+):([0-9a-f]+)\s(.+)'
    devices = []
    for line in output.strip().split('\n'):
        sre = re.match(regexp, line, re.I)
        if not sre:
            _error_exit("sorry, your system's `lsusb` is producing a strange "
                "output")
        if not sre.group(3).strip():  # If it has no name, skip it.
            continue
        devices.append({
                'vid': sre.group(1),
                'pid': sre.group(2),
                'name': sre.group(3)
            })

    return _get_input(devices)


def get_commands(device):
    """Return usb_modeswitch's commands.

    It puts specific commands for the given device at the beginning
    (that is if we know the device).
    """
    _cmds = {
        'mobileaction': ['-A'],
        'qisda':        ['-B'],
        'quanta':       ['-E'],
        'gct':          ['-G'],
        'huawei':       ['-J', '-H', '-X'],
        'cisco':        ['-L'],
        'sequans':      ['-N'],
        'sony':         ['-O'],
        'sierra':       ['-S'],
        'option':       ['-S'],
        'kobil':        ['-T'],
        'blackberry':   ['-Z'],
        'd-link':       ['-u 2']
    }
    
    cmds = ['-K', '-d']
    # - Pick command for the detected modem and put it at the beginning.
    # NOTE: We have already inserted the general commands (which are a
    # second preference to the vendor-specific ones).
    for k in _cmds.keys():
        if re.search(r' {k}|{k} '.format(k=re.escape(k)),device['name'],re.I):
            # print('/we know this device/:', device['name'])
            cmds = _cmds[k] + cmds
            break

    return cmds


def apply_commands(cmds, vid, pid):
    """Apply given commands, returning the first one to work."""
    def _send_cmds(*args):
        print("." * len(args))
        # Only wait if the process exit status is 0.  Any other status
        # isn't a sign of success.
        if subprocess.call(
                ['usb_modeswitch', '-v',vid, '-p',pid] + list(args),
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
        ) == 0:
            for i in range(85):
                time.sleep(0.1)  # 8.5 seconds
                if is_detected():
                    return True

    for c in cmds:
        trials = [
            (c,),
            (c, '-n'),
            (c, '-R')
        ]
        for t in trials:
            if _send_cmds(*t):
                return " ".join(t)


def edit_rules(new_rule):
    """Edit mode-switch rules, adding the new one to the bottom.

    It backs up the original file in the current directory and edits
    the real one.
    """
    shutil.copy2(RULES_FILE, './')

    _rules = ""
    with open(RULES_FILE) as filo:
        _rules = filo.read().rstrip() #

    rules = _rules.split("\n")
    rules.insert(-1, new_rule)
    with open(RULES_FILE, "w") as filo:
        for line in rules:
            filo.write(line)
            filo.write("\n")


def main():
    """Run the whole thing."""

    # - Process arguments.
    options = {
        '--edit-rules': {
            'action': _set_edit_rules,
            'exit': False
        },

        '--help': {
            'action': print_help,
            'exit': True
        }
    }
    _process_args(options, sys.argv[1:])

    # - Check if modem is already detected.
    if is_detected():
        print("it seems the modem is already detected by the system")
        exit()

    # - Check if machine has required tools.  (We only need the tools
    #   if the modem isn't detected).
    tools = [
        "lsusb",
        "usb_modeswitch",
        "udevadm"
    ]
    for t in tools:
        if not _check_tool(t):
            _error_exit("`{}` isn't available on your system. please"
                " install it first.".format(t))

    # - Check if we're root.
    if os.geteuid() != 0:
        _error_exit("please run this program as root")


    # - Get to work.
    device = choose_device()
    print()
    print("getting to work")
    commands = get_commands(device)
    _cmd = apply_commands(commands, device['vid'], device['pid'])
    if _cmd:
        cmd = RULE.format(
                product=device['name'],
                vid=device['vid'],
                pid=device['pid'],
                usb_modeswitch=shutil.which('usb_modeswitch'),
                cmd=_cmd
            )

        print()
        print("good news! modem state switched")
        if should_edit_rules:  # Edit the rules and return.  Don't print
                               # the command.
            try:
                edit_rules(cmd)
            except FileNotFoundError:
                print("(but didn't find the rules file)",file=sys.stderr)
            else:
                print("(and rules successfully edited)")
                subprocess.call(["udevadm", "control", "--reload-rules"])
            return
        print()
        print("mode-switch command")
        print("-------------------")
        print(cmd, end="")
    else:
        print()
        print()
        _error_exit("sorry pal, it didn't work")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()